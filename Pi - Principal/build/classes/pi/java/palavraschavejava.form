<?xml version="1.0" encoding="UTF-8" ?>

<Form version="1.3" maxVersion="1.9" type="org.netbeans.modules.form.forminfo.JFrameFormInfo">
  <Properties>
    <Property name="defaultCloseOperation" type="int" value="3"/>
  </Properties>
  <SyntheticProperties>
    <SyntheticProperty name="formSizePolicy" type="int" value="1"/>
    <SyntheticProperty name="generateCenter" type="boolean" value="false"/>
  </SyntheticProperties>
  <AuxValues>
    <AuxValue name="FormSettings_autoResourcing" type="java.lang.Integer" value="0"/>
    <AuxValue name="FormSettings_autoSetComponentName" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_generateFQN" type="java.lang.Boolean" value="true"/>
    <AuxValue name="FormSettings_generateMnemonicsCode" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_i18nAutoMode" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_layoutCodeTarget" type="java.lang.Integer" value="2"/>
    <AuxValue name="FormSettings_listenerGenerationStyle" type="java.lang.Integer" value="0"/>
    <AuxValue name="FormSettings_variablesLocal" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_variablesModifier" type="java.lang.Integer" value="2"/>
  </AuxValues>

  <Layout>
    <DimensionLayout dim="0">
      <Group type="103" groupAlignment="0" attributes="0">
          <Group type="102" alignment="0" attributes="0">
              <EmptySpace max="-2" attributes="0"/>
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace min="0" pref="391" max="32767" attributes="0"/>
                      <Component id="jLabel2" min="-2" pref="284" max="-2" attributes="0"/>
                      <EmptySpace min="-2" pref="320" max="-2" attributes="0"/>
                      <Component id="jButton1" min="-2" pref="106" max="-2" attributes="0"/>
                  </Group>
                  <Component id="jScrollPane1" max="32767" attributes="0"/>
              </Group>
              <EmptySpace type="separate" max="-2" attributes="0"/>
              <Component id="jLabel1" min="-2" max="-2" attributes="0"/>
          </Group>
      </Group>
    </DimensionLayout>
    <DimensionLayout dim="1">
      <Group type="103" groupAlignment="0" attributes="0">
          <Group type="102" attributes="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace min="-2" pref="131" max="-2" attributes="0"/>
                      <Component id="jLabel1" min="-2" max="-2" attributes="0"/>
                      <EmptySpace min="0" pref="0" max="32767" attributes="0"/>
                  </Group>
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Group type="103" groupAlignment="3" attributes="0">
                          <Component id="jLabel2" alignment="3" min="-2" max="-2" attributes="0"/>
                          <Component id="jButton1" alignment="3" min="-2" max="-2" attributes="0"/>
                      </Group>
                      <EmptySpace min="-2" pref="16" max="-2" attributes="0"/>
                      <Component id="jScrollPane1" pref="717" max="32767" attributes="0"/>
                  </Group>
              </Group>
              <EmptySpace max="-2" attributes="0"/>
          </Group>
      </Group>
    </DimensionLayout>
  </Layout>
  <SubComponents>
    <Container class="javax.swing.JScrollPane" name="jScrollPane1">
      <Properties>
        <Property name="border" type="javax.swing.border.Border" editor="org.netbeans.modules.form.editors2.BorderEditor">
          <Border info="org.netbeans.modules.form.compat2.border.MatteColorBorderInfo">
            <MatteColorBorder/>
          </Border>
        </Property>
      </Properties>

      <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
      <SubComponents>
        <Component class="javax.swing.JTextArea" name="jTextArea1">
          <Properties>
            <Property name="editable" type="boolean" value="false"/>
            <Property name="columns" type="int" value="20"/>
            <Property name="font" type="java.awt.Font" editor="org.netbeans.beaninfo.editors.FontEditor">
              <Font name="Microsoft Sans Serif" size="15" style="1"/>
            </Property>
            <Property name="rows" type="int" value="5"/>
            <Property name="text" type="java.lang.String" value="1 - abstract&#xa;Um m&#xe9;todo sem defini&#xe7;&#xe3;o deve ser declarado como abstrato(abstract) e a classe que o cont&#xe9;m tamb&#xe9;m deve ser declarada como abstrata. Classes abstratas n&#xe3;o podem ser instanciadas e os m&#xe9;todos abstratos devem ser implementados nas subclasses. Outro detalhe &#xe9; que uma classe abstrata n&#xe3;o obrigatoriamente tem um m&#xe9;todo abstrato, mas um m&#xe9;todo abstrato s&#xf3; pode estar numa classe abstrata.&#xa;&#xa;2 - assert&#xa;O assert descreve um predicado(uma declara&#xe7;&#xe3;o de verdadeiro ou falso) colocado em uma aplica&#xe7;&#xe3;o Java para indicar se o valor passado para o predicado &#xe9; verdadeiro ou falso. Se a asser&#xe7;&#xe3;o for avaliada como falsa em tempo de execu&#xe7;&#xe3;o, ocorrer&#xe1; uma falha de asser&#xe7;&#xe3;o.&#xa;&#xa;3 - boolean&#xa;Define uma vari&#xe1;vel booleana apenas para os valores &#x201c;true&#x201d; ou &#x201c;false&#x201d;. Por padr&#xe3;o, o valor do tipo primitivo booleano &#xe9; falso. Essa palavra chave tamb&#xe9;m &#xe9; usada para declarar que um m&#xe9;todo retorna um valor do tipo primitivo booleano.&#xa;&#xa;4 - break&#xa;Usado para finalizar a execu&#xe7;&#xe3;o no corpo do loop atual.&#xa;&#xa;5 - byte&#xa;A palavra chave byte &#xe9; usada para declarar um campo que pode conter um n&#xfa;mero inteiro de complemento de dois assinado de 8 bits. Essa palavra chave tamb&#xe9;m &#xe9; usada para declarar que um m&#xe9;todo retorna um valor do tipo primitivo byte.&#xa;&#xa;6 - case&#xa;Um bloco switch pode ser identificado com um ou mais &#x201c;case&#x201d; ou com um identificador &#x201c;default&#x201d;. A instru&#xe7;&#xe3;o switch avalia sua express&#xe3;o e, em seguida executa todas as instru&#xe7;&#xf5;es que seguem o identificador &#x201c;case&#x201d; correspondente.&#xa;&#xa;7 - catch&#xa;Utilizado em conjunto com um bloco &#x201c;try&#x201d; e em um bloco opcional &#x201c;finally&#x201d;. As instru&#xe7;&#xf5;es no bloco &#x201c;catch&#x201d; especificam o que fazer se um tipo espec&#xed;fico de exce&#xe7;&#xe3;o for lan&#xe7;ado pelo bloco &#x201c;try&#x201d;.&#xa;&#xa;8 - char&#xa;Define uma vari&#xe1;vel de caractere capaz de conter qualquer caractere do conjunto de caracteres suportados pelo Java.&#xa;&#xa;9 - class&#xa;Uma palavra que define a implementa&#xe7;&#xe3;o de um tipo espec&#xed;fico de objeto. Uma defini&#xe7;&#xe3;o de classe define vari&#xe1;veis de classe e de inst&#xe2;ncia, m&#xe9;todos e classes internas, al&#xe9;m de especificar as interfaces que a classe implementa e a superclasse imediata da classe. Se a superclasse n&#xe3;o for especificada explicitamente, a superclasse &#xe9; implicitamente Object. A palavra chave class tamb&#xe9;m pode ser usada no formato Class.class para obter um objeto Class sem precisar de uma inst&#xe2;ncia dessa classe. Por exemplo, String.class pode ser usado em vez de fazer new String().getClass();.&#xa;&#xa;10 - const&#xa;N&#xe3;o utilizado, por&#xe9;m &#xe9; reservada.&#xa;&#xa;11 - continue&#xa;Usado para retomar a execu&#xe7;&#xe3;o do programa no final do corpo do loop atual. Se seguido por um identificador continue, retoma a execu&#xe7;&#xe3;o no final do corpo do loop identificado.&#xa;&#xa;12 - default&#xa;A palavra chave default pode opcionalmente ser usada em uma instru&#xe7;&#xe3;o switch para identificar um bloco de instru&#xe7;&#xf5;es a ser executado se nenhum caso corresponder ao valor especificado. Como alternativa, a palavra chave default tamb&#xe9;m pode ser usada para declarar valores padr&#xe3;o em uma anota&#xe7;&#xe3;o Java. A partir do Java 8, palavra chave default pode ser usada para permitir que uma interface forne&#xe7;a uma implementa&#xe7;&#xe3;o de um m&#xe9;todo.&#xa;&#xa;13 - do&#xa;A palavra chave do &#xe9; usada em conjunto com o while para criar um loop do-while, que executa um bloco de instru&#xe7;&#xf5;es associadas ao loop e testa uma express&#xe3;o booleana associada ao while. Se a express&#xe3;o for avaliada como verdadeira, o bloco ser&#xe1; executado novamente, isso continua at&#xe9; que a express&#xe3;o seja avaliada como falsa.&#xa;&#xa;14 - double&#xa;A palavra chave double &#xe9; usada para declarar uma vari&#xe1;vel que pode conter um n&#xfa;mero de ponto flutuante IEEE 754 de precis&#xe3;o dupla de 64 bits. Essa palavra chave tamb&#xe9;m &#xe9; usada para declarar que um m&#xe9;todo retorna um valor do tipo primitivo double.&#xa;&#xa;15 - else&#xa;A palavra chave else &#xe9; usada em conjunto com if para criar uma instru&#xe7;&#xe3;o if-else, que testa uma express&#xe3;o booleana, se a express&#xe3;o for avaliada como verdadeira, o bloco de instru&#xe7;&#xf5;es associado ao if ser&#xe1; avaliada, se avaliado como falso, o bloco de instru&#xe7;&#xf5;es associado ao else &#xe9; avaliado.&#xa;&#xa;16 - enum&#xa;A palavra chave enum &#xe9; usada para declarar um tipo enumerado. Enumera&#xe7;&#xf5;es estendem a classe base Enum.&#xa;&#xa;17 - extends&#xa;Usado em uma declara&#xe7;&#xe3;o de classe para especificar a superclasse, usado em uma declara&#xe7;&#xe3;o de interface para especificar uma ou mais superinterfaces. A classe X estende a classe Y para adicionar funcionalidade, adicionando campos ou m&#xe9;todos a classe Y ou substituindo m&#xe9;todos da classe Y. Uma interface Z estende uma ou mais interfaces adicionando m&#xe9;todos. A classe X &#xe9; considerada uma subclasse da classe Y. A interface Z &#xe9; considerada uma subinterface das interfaces que ela se estende. Tamb&#xe9;m usado para especificar um limite superior em um par&#xe2;metro de tipo em Generics.&#xa;&#xa;18 - final&#xa;Define uma entidade uma vez que n&#xe3;o possa ser alterada nem derivada posteriormente. Mais especificamente: uma classe final n&#xe3;o pode ser subclassificada, um m&#xe9;todo final n&#xe3;o pode ser substituido e uma vari&#xe1;vel final pode ocorrer no m&#xe1;ximo uma vez como uma express&#xe3;o left-hand em um comando executado. Todos os m&#xe9;todos em uma classe final s&#xe3;o implicitamente finais.&#xa;&#xa;19 - finally&#xa;Usado para definir um bloco de instru&#xe7;&#xf5;es para um bloco definido anteriormente pela palavra chave try. O bloco finally &#xe9; executado ap&#xf3;s a execu&#xe7;&#xe3;o sair do bloco try e de qualquer cl&#xe1;usula catch associada, independentemente de uma execu&#xe7;&#xe3;o ter sido lan&#xe7;ada ou capturada ou se a execu&#xe7;&#xe3;o parou no meio dos blocos try ou catch usando a palavra chave return&#xa;&#xa;20 - float&#xa;A palavra chave float &#xe9; usada para declarar uma vari&#xe1;vel que pode conter um n&#xfa;mero de ponto flutuante IEEE 754 de precis&#xe3;o &#xfa;nica de 32 bits. Essa palavra chave tamb&#xe9;m &#xe9; usada para declarar que um m&#xe9;todo retorna um valor do tipo primitivo float.&#xa;&#xa;21 - for&#xa;A palavra chave for &#xe9; usada para criar um loop for, que especifica uma inicializa&#xe7;&#xe3;o de vari&#xe1;vel, uma express&#xe3;o booleana e um incremento. A inicializa&#xe7;&#xe3;o da vari&#xe1;vel &#xe9; realizada primeiro e, em seguida, a express&#xe3;o booleana &#xe9; avaliada. Se a express&#xe3;o for avaliada como verdadeira, o bloco de instru&#xe7;&#xf5;es associado ao loop ser&#xe1; executado. A express&#xe3;o booleana &#xe9; ent&#xe3;o avaliada novamente, isso continua at&#xe9; que a express&#xe3;o seja avaliada como falsa. A partir do J2SE 5.0, a palavra chave for tamb&#xe9;m pode ser usada para criar o chamado &#x201c;enhanced for loop&#x201d; que especifica uma matriz ou objeto iter&#xe1;vel, cada itera&#xe7;&#xe3;o do loop executa o bloco de instru&#xe7;&#xf5;es associado usando um elemento diferente na matriz ou Iterable.&#xa;&#xa;22 - goto&#xa;N&#xe3;o utilizada, por&#xe9;m reservado.&#xa;&#xa;23 - if&#xa;A palavra chave if &#xe9; usada para criar uma instru&#xe7;&#xe3;o if, que testa uma express&#xe3;o booleana, se a express&#xe3;o for avaliada como verdadeira, o bloco de instru&#xe7;&#xf5;es associado a instru&#xe7;&#xe3;o if ser&#xe1; executado. Essa palavra chave tamb&#xe9;m pode ser usada para criar uma instru&#xe7;&#xe3;o if-else.&#xa;&#xa;24 - implements&#xa;Inclu&#xed;do em uma declara&#xe7;&#xe3;o de classe para especificar uma ou mais interfaces implementadas pela classe atual. Uma classe herda os tipos e m&#xe9;todos abstratos declarados pelas interfaces.&#xa;&#xa;25 - import&#xa;Usado no inicio de um arquivo de c&#xf3;digo-fonte para especificar classes ou pacotes Java inteiros a serem consultados posteriormente, sem incluir seus nomes de pacotes na refer&#xea;ncia. Desde o J2SE 5.0, as instru&#xe7;&#xf5;es de importa&#xe7;&#xe3;o podem importar membros est&#xe1;ticos de uma classe.&#xa;&#xa;26 - instanceof&#xa;Um operador bin&#xe1;rio que recebe uma refer&#xea;ncia de objeto como seu primeiro operando e uma classe ou interface como seu segundo operando e produz um resultado booleano. O operador instanceof avalia como true se e somente se o tipo de tempo de execu&#xe7;&#xe3;o do objeto &#xe9; uma atribui&#xe7;&#xe3;o compat&#xed;vel com a classe ou interface.&#xa;&#xa;27 - int&#xa;A palavra chave int &#xe9; usada para declarar uma vari&#xe1;vel que pode conter um inteiro de complemento de dois de 32 bits. Essa palavra chave tamb&#xe9;m &#xe9; usada para declarar que um m&#xe9;todo retorna um valor do tipo primitivo int.&#xa;&#xa;28 - interface&#xa;Usado para declarar um tipo especial de classe que cont&#xe9;m apenas m&#xe9;todos abstratos ou padr&#xe3;o, campos constantes(est&#xe1;ticos, finais) e interfaces est&#xe1;ticas. Posteriormente, ele pode ser implementado por classes que declaram a interface com a palavra chave implements. Como a heran&#xe7;a m&#xfa;ltipla n&#xe3;o &#xe9; permitida em Java, as interfaces s&#xe3;o usadas para contorn&#xe1;-la. Uma interface pode ser definida dentro de outra interface.&#xa;&#xa;29 - long&#xa;A palavra chave long &#xe9; usada para declarar uma vari&#xe1;vel que pode conter um inteiro de complemento de dois assinados de 64 bits. Essa palavra chave tamb&#xe9;m &#xe9; usada para declarar que um m&#xe9;todo retorna um valor do tipo primitivo por muito tempo.&#xa;&#xa;30 - native&#xa;Usado nas declara&#xe7;&#xf5;es do m&#xe9;todo para especificar que o m&#xe9;todo n&#xe3;o &#xe9; implementado no mesmo arquivo de c&#xf3;digo Java, mas em outra linguagem.&#xa;&#xa;31 - new&#xa;Usado para criar uma inst&#xe2;ncia de um objeto de classe ou matriz. O uso da palavra chave para esse fim n&#xe3;o &#xe9; completamente necess&#xe1;rio(como exemplificado pelo Scala), embora atenda a dois prop&#xf3;sitos: permite a exist&#xea;ncia de um espa&#xe7;o de nome diferente para m&#xe9;todos e nomes de classes, define estaticamente e localmente que um objeto novo &#xe9; realmente criado e que tipo de runtime &#xe9;.&#xa;&#xa;32 - package&#xa;Um pacote Java &#xe9; um grupo de classes e interfaces semelhantes. Pacotes s&#xe3;o declarados com a palavra chave package.&#xa;&#xa;33 - private&#xa;A palavra chave private &#xe9; usada na declara&#xe7;&#xe3;o de um m&#xe9;todo, campo ou classe interna, membros privados s&#xf3; podem ser acessados por outros membros de sua pr&#xf3;pria classe.&#xa;&#xa;34 - protected&#xa;A palavra chave protected &#xe9; usada na declara&#xe7;&#xe3;o de um m&#xe9;todo, campo ou classe interna, membros protegidos s&#xf3; podem ser acessados por membros de sua pr&#xf3;pria classe, subclasses ou classes dessa classe do mesmo pacote.&#xa;&#xa;35 - public&#xa;A palavra chave public &#xe9; usada na declara&#xe7;&#xe3;o de uma classe, m&#xe9;todo ou campo, classes p&#xfa;blicas, m&#xe9;todos e campos podem ser acessados pelos membros de qualquer classe.&#xa;&#xa;36 - return&#xa;Usado para concluir a execu&#xe7;&#xe3;o de um m&#xe9;todo. Pode ser seguido por um valor exigido pela defini&#xe7;&#xe3;o do m&#xe9;todo que &#xe9; retornada ao chamador.&#xa;&#xa;37 - short&#xa;A palavra chave short &#xe9; usada para declarar um campo que pode conter um n&#xfa;mero inteiro de complemento de dois de 16 bits. Essa palavra chave tamb&#xe9;m &#xe9; usada para declarar que um m&#xe9;todo retorna um valor do tipo primitivo short.&#xa;&#xa;38 - static&#xa;Usada para declarar um campo, m&#xe9;todo ou classe interna como um campo de classe. As classes mant&#xea;m uma c&#xf3;pia dos campos da classe independentemente de quantas inst&#xe2;ncias existem nessa classe. static tamb&#xe9;m &#xe9; usado para definir um m&#xe9;todo como um m&#xe9;todo de classe. Os m&#xe9;todos de classe s&#xe3;o vinculados a classe em vez de a uma inst&#xe2;ncia espec&#xed;fica e s&#xf3; podem operar em campos de classe.&#xa;&#xa;39 - strictfp&#xa;Usada para restringir a precis&#xe3;o e o arredondamento dos c&#xe1;lculos de ponto flutuante para garantir a portabilidade.&#xa;&#xa;40 - super&#xa;Usada para obter binding din&#xe2;mico ou polimorfismo em tempo de execu&#xe7;&#xe3;o. Usado tamb&#xe9;m para acessar membros de uma classe herdada pela classe em que ela aparece. Permite que uma subclasse acesse m&#xe9;todos substitu&#xed;dos e membros ocultos de sua superclasse. A palavra chave super tamb&#xe9;m pode ser usada para encaminhar uma chamada de um construtor para um construtor na superclasse. E tamb&#xe9;m &#xe9; usado para especificar um limite inferior em um par&#xe2;metro de tipo em Generics.&#xa;&#xa;41 - switch&#xa;A palavra chave switch &#xe9; usada em conjunto com case e default para criar uma instru&#xe7;&#xe3;o switch, que avalia uma vari&#xe1;vel, combina seu valor com um caso espec&#xed;fico e executa o bloco de instru&#xe7;&#xf5;es associado a esse case. Se nenhum case corresponder ao valor, o bloco opcional identificado pelo default ser&#xe1; executado.&#xa;&#xa;42 - synchronized&#xa;Usado na declara&#xe7;&#xe3;o de um m&#xe9;todo ou bloco de c&#xf3;digo para adquirir o mutex lock para um objeto enquanto a thread atual executa o c&#xf3;digo. Para m&#xe9;todos est&#xe1;ticos, o objeto bloqueado &#xe9; a classe Class. Garante que, no m&#xe1;ximo exista uma thread de cada vez operando no mesmo objeto e executando esse c&#xf3;digo. O mutex lock &#xe9; liberado automaticamente quando a execu&#xe7;&#xe3;o sai do c&#xf3;digo sincronizado. Campos, classes e interfaces n&#xe3;o podem ser declarados como synchronized.&#xa;&#xa;43 - this&#xa;Usado para representar uma inst&#xe2;ncia da classe em que aparece. this pode ser usado para acessar os membros da classe e como uma refer&#xea;ncia a inst&#xe2;ncia atual. A palavra chave this tamb&#xe9;m &#xe9; usada para encaminhar uma chamada de um construtor em uma classe para outro construtor na mesma classe.&#xa;&#xa;44 - throw&#xa;Faz com que a inst&#xe2;ncia da exce&#xe7;&#xe3;o declarada seja lan&#xe7;ada. Isso faz com que a execu&#xe7;&#xe3;o continue com o primeiro handler de exce&#xe7;&#xe3;o em anexo declarado pela palavra chave catch para manipular um tipo de exce&#xe7;&#xe3;o compat&#xed;vel com a atribui&#xe7;&#xe3;o. Se nenhum handler de exce&#xe7;&#xe3;o for encontrado no m&#xe9;todo atual, o m&#xe9;todo retornar&#xe1; e o processo ser&#xe1; repetido no m&#xe9;todo da chamada. Se nenhum handler de exce&#xe7;&#xf5;es for encontrado em qualquer chamada de m&#xe9;todo na pilha, a exce&#xe7;&#xe3;o ser&#xe1; passada para o handler de exce&#xe7;&#xf5;es n&#xe3;o capturadas da thread.&#xa;&#xa;45 - throws&#xa;Usado nas declara&#xe7;&#xf5;es do m&#xe9;todo para especificar quais exce&#xe7;&#xf5;es n&#xe3;o s&#xe3;o tratadas no m&#xe9;todo, mas passadas para o pr&#xf3;ximo n&#xed;vel mais alto do programa. Todas as exce&#xe7;&#xf5;es n&#xe3;o capturadas em um m&#xe9;todo que n&#xe3;o s&#xe3;o inst&#xe2;ncias de RuntimeException devem ser declaradas usando a palavra chave throws.&#xa;&#xa;46 - transient&#xa;Declara que um campo de inst&#xe2;ncia n&#xe3;o faz parte do formul&#xe1;rio serializado padr&#xe3;o de um objeto. Quando um objeto &#xe9; serializado, apenas os valores de seus campos de inst&#xe2;ncias n&#xe3;o transit&#xf3;rios s&#xe3;o inclu&#xed;dos na representa&#xe7;&#xe3;o serial padr&#xe3;o. Quando um objeto &#xe9; desserializado, os campos transit&#xf3;rios s&#xe3;o inicializados apenas com o valor padr&#xe3;o. Se o formul&#xe1;rio padr&#xe3;o n&#xe3;o for usado, por exemplo, quando uma tabela serialPersistentFields &#xe9; declarada na hierarquia de classes, todas as palavra chave transient s&#xe3;o ignoradas.&#xa;&#xa;47 - try&#xa;Define um bloco de instru&#xe7;&#xf5;es que possuem manipula&#xe7;&#xe3;o ou handling de exce&#xe7;&#xe3;o. Se uma exce&#xe7;&#xe3;o for lan&#xe7;ada dentro do bloco try, um bloco catch opcional poder&#xe1; manipular os tipos de exce&#xe7;&#xe3;o declarados. Al&#xe9;m disso, pode ser declarado um bloco finally opcional que ser&#xe1; executado quando a execu&#xe7;&#xe3;o sair das cl&#xe1;usulas try e catch, independentemente de uma exce&#xe7;&#xe3;o ser lan&#xe7;ada ou n&#xe3;o. Um bloco try deve ter pelo menos uma cl&#xe1;usula catch ou um bloco finally.&#xa;&#xa;48 - void&#xa;A palavra chave void &#xe9; usada para declarar que um m&#xe9;todo n&#xe3;o retorna nenhum valor.&#xa;&#xa;49 - volatile&#xa;Utilizada em declara&#xe7;&#xf5;es de campo para garantir a visibilidade das altera&#xe7;&#xf5;es nas vari&#xe1;veis atrav&#xe9;s das threads. Toda leitura de uma vari&#xe1;vel vol&#xe1;til ser&#xe1; lida na mem&#xf3;ria principal e n&#xe3;o no cache da CPU, e todas as grava&#xe7;&#xf5;es em uma vari&#xe1;vel vol&#xe1;til ser&#xe3;o gravadas na mem&#xf3;ria principal, e n&#xe3;o apenas no cache da CPU. M&#xe9;todos, classes e interfaces, portanto, n&#xe3;o podem ser declarados vol&#xe1;teis, nem vari&#xe1;veis ou par&#xe2;metros locais.&#xa;&#xa;50 - while&#xa;A palavra chave while &#xe9; usada para criar um loop while, que testa uma express&#xe3;o booleana e executa o bloco de instru&#xe7;&#xf5;es associado ao loop se a express&#xe3;o for avaliada como verdadeira, isso continua at&#xe9; que a express&#xe3;o seja avaliada como falsa. Essa palavra chave tamb&#xe9;m pode ser usada para criar um loop do-while.&#xa;true, false e null&#xa;&#xa;Temos ainda os casos especiais de palavras reservadas que s&#xe3;o usadas para valores literais.&#xa;&#xa;true = valor booleano literal para verdadeiro. false = valor booleano literal para falso. null = valor literal de refer&#xea;ncia.&#xa;identificadores especiais&#xa;&#xa;var = identificador especial que n&#xe3;o pode ser usado como um nome de tipo(inclu&#xed;do no Java 10). _ = Adicionado no Java 11, o underscore tornou-se uma palavra chave e n&#xe3;o pode mais ser usado como nome de vari&#xe1;vel.&#xa;n&#xe3;o utilizados&#xa;&#xa;const = embora reservada como palavra chave, const n&#xe3;o &#xe9; usada e n&#xe3;o tem fun&#xe7;&#xe3;o. Para definir constantes em Java &#xe9; normal utilizarmos a palavra chave final.&#xa;&#xa;goto = embora reservada como palavra chave, goto n&#xe3;o &#xe9; usado e n&#xe3;o tem fun&#xe7;&#xe3;o.&#xa;"/>
          </Properties>
        </Component>
      </SubComponents>
    </Container>
    <Component class="javax.swing.JLabel" name="jLabel1">
    </Component>
    <Component class="javax.swing.JLabel" name="jLabel2">
      <Properties>
        <Property name="font" type="java.awt.Font" editor="org.netbeans.beaninfo.editors.FontEditor">
          <Font name="Microsoft Sans Serif" size="36" style="1"/>
        </Property>
        <Property name="text" type="java.lang.String" value="Palavras-chave"/>
        <Property name="border" type="javax.swing.border.Border" editor="org.netbeans.modules.form.editors2.BorderEditor">
          <Border info="org.netbeans.modules.form.compat2.border.MatteColorBorderInfo">
            <MatteColorBorder/>
          </Border>
        </Property>
      </Properties>
    </Component>
    <Component class="javax.swing.JButton" name="jButton1">
      <Properties>
        <Property name="text" type="java.lang.String" value="Sair"/>
      </Properties>
      <Events>
        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="jButton1ActionPerformed"/>
      </Events>
    </Component>
  </SubComponents>
</Form>
